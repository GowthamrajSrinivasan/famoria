import { db } from '../lib/firebase';
import { 
  collection, 
  doc, 
  updateDoc, 
  arrayUnion, 
  arrayRemove, 
  addDoc, 
  query, 
  orderBy, 
  onSnapshot,
  deleteDoc,
  increment,
  getDoc
} from 'firebase/firestore';
import { Comment } from '../types';

export const interactionService = {
  // --- LIKES ---

  toggleLike: async (photoId: string, userId: string): Promise<boolean> => {
    const photoRef = doc(db, 'photos', photoId);
    
    // Check if currently liked to determine action
    const snapshot = await getDoc(photoRef);
    if (!snapshot.exists()) throw new Error("Photo not found");
    
    const likes = snapshot.data().likes || [];
    const isLiked = likes.includes(userId);

    if (isLiked) {
      await updateDoc(photoRef, {
        likes: arrayRemove(userId)
      });
      return false;
    } else {
      await updateDoc(photoRef, {
        likes: arrayUnion(userId)
      });
      return true;
    }
  },

  subscribeToLikes: (photoId: string, callback: (userIds: string[]) => void) => {
    const photoRef = doc(db, 'photos', photoId);
    return onSnapshot(photoRef, (doc) => {
      if (doc.exists()) {
        callback(doc.data().likes || []);
      } else {
        callback([]);
      }
    });
  },

  // --- COMMENTS ---

  // Fix: Omit 'createdAt' from the input type because it is generated by the service.
  addComment: async (comment: Omit<Comment, 'id' | 'createdAt'>): Promise<Comment> => {
    const timestamp = Date.now();
    // 1. Add comment to subcollection
    const commentsRef = collection(db, 'photos', comment.photoId, 'comments');
    const docRef = await addDoc(commentsRef, {
      ...comment,
      createdAt: timestamp
    });

    // 2. Update photo comment count
    const photoRef = doc(db, 'photos', comment.photoId);
    await updateDoc(photoRef, {
      commentsCount: increment(1)
    });

    return { ...comment, id: docRef.id, createdAt: timestamp };
  },

  deleteComment: async (photoId: string, commentId: string) => {
    await deleteDoc(doc(db, 'photos', photoId, 'comments', commentId));
    
    const photoRef = doc(db, 'photos', photoId);
    await updateDoc(photoRef, {
      commentsCount: increment(-1)
    });
  },

  subscribeToComments: (photoId: string, callback: (comments: Comment[]) => void) => {
    const commentsRef = collection(db, 'photos', photoId, 'comments');
    const q = query(commentsRef, orderBy('createdAt', 'desc')); // Newest first

    return onSnapshot(q, (snapshot) => {
      const comments = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      } as Comment));
      // Reverse to show oldest first in UI if preferred, 
      // but CommentSection usually wants chronological or reverse chronological.
      // Let's sort chronological for chat-like feel.
      callback(comments.sort((a, b) => a.createdAt - b.createdAt));
    });
  }
};