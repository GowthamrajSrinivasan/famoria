import { db } from '../lib/firebase';
import {
  collection,
  doc,
  updateDoc,
  arrayUnion,
  arrayRemove,
  addDoc,
  query,
  where,
  orderBy,
  onSnapshot,
  deleteDoc,
  increment,
  getDoc
} from 'firebase/firestore';
import { Comment } from '../types';

export const interactionService = {
  // --- LIKES ---

  toggleLike: async (photoId: string, userId: string, collectionName: 'photos' | 'posts' | 'videos' = 'posts'): Promise<boolean> => {
    const photoRef = doc(db, collectionName, photoId);

    // Check if currently liked to determine action
    const snapshot = await getDoc(photoRef);
    if (!snapshot.exists()) throw new Error("Photo/Post/Video not found");

    const likes = snapshot.data().likes || [];
    const isLiked = likes.includes(userId);

    if (isLiked) {
      await updateDoc(photoRef, {
        likes: arrayRemove(userId)
      });
      return false;
    } else {
      await updateDoc(photoRef, {
        likes: arrayUnion(userId)
      });
      return true;
    }
  },

  subscribeToLikes: (photoId: string, callback: (userIds: string[]) => void, collectionName: 'photos' | 'posts' | 'videos' = 'posts') => {
    const photoRef = doc(db, collectionName, photoId);
    return onSnapshot(photoRef, (doc) => {
      if (doc.exists()) {
        callback(doc.data().likes || []);
      } else {
        callback([]);
      }
    });
  },

  // --- COMMENTS ---

  // Fix: Omit 'createdAt' from the input type because it is generated by the service.
  addComment: async (comment: Omit<Comment, 'id' | 'createdAt'>, collectionName: 'photos' | 'posts' = 'posts'): Promise<Comment> => {
    // Guard against undefined photoId
    if (!comment.photoId) {
      throw new Error('[InteractionService] Cannot add comment: photoId is undefined');
    }

    const timestamp = Date.now();
    // 1. Add comment to subcollection
    const commentsRef = collection(db, collectionName, comment.photoId, 'comments');
    const docRef = await addDoc(commentsRef, {
      ...comment,
      likes: [], // Initialize likes array
      createdAt: timestamp
    });

    // 2. Update photo/post comment count
    const photoRef = doc(db, collectionName, comment.photoId);
    await updateDoc(photoRef, {
      commentsCount: increment(1)
    });

    return { ...comment, id: docRef.id, likes: [], createdAt: timestamp };
  },

  deleteComment: async (photoId: string, commentId: string, collectionName: 'photos' | 'posts' = 'posts') => {
    await deleteDoc(doc(db, collectionName, photoId, 'comments', commentId));

    const photoRef = doc(db, collectionName, photoId);
    await updateDoc(photoRef, {
      commentsCount: increment(-1)
    });
  },

  updateComment: async (photoId: string, commentId: string, newText: string, collectionName: 'photos' | 'posts' = 'posts') => {
    const commentRef = doc(db, collectionName, photoId, 'comments', commentId);
    await updateDoc(commentRef, {
      text: newText,
      updatedAt: Date.now()
    });
  },

  toggleCommentLike: async (photoId: string, commentId: string, userId: string, collectionName: 'photos' | 'posts' = 'posts'): Promise<boolean> => {
    const commentRef = doc(db, collectionName, photoId, 'comments', commentId);

    // Check if currently liked
    const snapshot = await getDoc(commentRef);
    if (!snapshot.exists()) throw new Error("Comment not found");

    const likes = snapshot.data().likes || [];
    const isLiked = likes.includes(userId);

    if (isLiked) {
      await updateDoc(commentRef, {
        likes: arrayRemove(userId)
      });
      return false;
    } else {
      await updateDoc(commentRef, {
        likes: arrayUnion(userId)
      });
      return true;
    }
  },

  subscribeToComments: (photoId: string, callback: (comments: Comment[]) => void, collectionName: 'photos' | 'posts' = 'posts') => {
    // Guard against undefined photoId
    if (!photoId) {
      console.warn('[InteractionService] subscribeToComments called with undefined photoId');
      callback([]);
      return () => { }; // Return empty unsubscribe function
    }

    const commentsRef = collection(db, collectionName, photoId, 'comments');
    const q = query(commentsRef, orderBy('createdAt', 'desc')); // Newest first

    return onSnapshot(q, (snapshot) => {
      const comments = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      } as Comment));
      // Reverse to show oldest first in UI if preferred, 
      // but CommentSection usually wants chronological or reverse chronological.
      // Let's sort chronological for chat-like feel.
      callback(comments.sort((a, b) => a.createdAt - b.createdAt));
    });
  }
};